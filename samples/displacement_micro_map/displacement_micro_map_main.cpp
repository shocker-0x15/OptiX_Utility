/*

JP: このサンプルはディスプレイスメントマッピングによる高密度ジオメトリを効率的に表現するための
    Displacement Micro-Map (DMM)の使用方法を示します。
    DMMは三角形メッシュにおけるハイトマップなどによる凹凸情報を三角形ごとにコンパクトに格納したものです。
    GASの生成時に追加情報として渡すことで三角形メッシュに高密度な凹凸を較的省メモリに追加することができます。
    逆に粗いメッシュにDMMを付加することで、通常の三角形メッシュよりも遥かに省メモリなGASで同様のジオメトリを
    表現することができますしGASのビルドも高速になります。
    OptiXのAPIにはDMM自体の生成処理は含まれていないため、何らかの手段を用いて生成する必要があります。
    DMM生成処理はテクスチャーとメッシュ間のマッピング、テクスチャー自体が静的な場合オフラインで予め行うことも可能です。
    このサンプルにはDMMの生成処理も行うコードパスとDisplacement Micro-Map SDK [1]によって事前計算された
    ファイルを読み込むコードパスの両方が用意されています。

    --no-dmm: DMMを無効化する。
    --visualize ***: 可視化モードを切り替える。
      - final: 最終レンダリング。
      - barycentric: 重心座標の可視化。ベース三角形の形状を確認できる。
      - micro-barycentric: マイクロ三角形の重心座標の可視化。
      - subdiv-level: 細分割レベルの可視化。
      - normal: 法線ベクトルの可視化。
    --use-pre-computed-mesh: NVIDIAのDMM SDKに含まれるツールを用いて作成したDMM計算済みのファイルを読み込む。
    --max-compressed-format ***: DMMのエンコードを強制的に指定する。
      - none: 強制しない。(自動的に決定される)
      - 64utris: DMMあたり64マイクロ三角形64Bのフォーマットを使う。
      - 256utris: DMMあたり256マイクロ三角形128Bのフォーマットを使う。
      - 1024utris: DMMあたり1024マイクロ三角形128Bのフォーマットを使う。
    --max-subdiv-level *: DMMの最大分割レベル。
    --subdiv-level-bias *: DMMの分割レベルへのバイアス。
    --displacement-bias *: ベース頂点のディスプレイスメントベクター方向への事前の移動量。
    --displacement-scale *: ベース頂点のディスプレイスメントベクター方向の変位スケール。
    --no-index-buffer: DMM用のインデックスバッファーを使用しない。

EN: This sample shows how to use Displacement Micro-Map (DMM) with which high-definition geometry by
    displacement mapping can be efficiently represented.
    DMM is a data structure which compactly stores per-triangle displacement information by height map or
    something else for a triangle mesh.
    Providing DMM as additional information when building a GAS adds high frequency geometric detail to
    a triangle mesh with relatively low additional memory.
    In other words, a geometry with similar complexity as a normal triangle mesh can be represented with
    a GAS with much less memory by adding DMM to a coarse mesh. This makes GAS build faster also.
    OptiX API doesn't provide generation of DMM itself, so DMM generation by some means is required.
    DMM generation can be offline pre-computation if the mapping between a texture and a mesh and
    the texture itself are static.
    This sample provides not only a code path where DMM generation is performed also,
    but also a code path reading a pre-computed file generated by Displacement Micro-Map SDK [1].

    --no-dmm: Disable DMM.
    --visualize ***: You can change visualizing mode.
      - final: Final rendering.
      - barycentric: Visualize barycentric coordinates, can be used to see the shapes of base triangles.
      - micro-barycentric: Visualize barycentric coordinates of micro-triangles.
      - subdiv-level: Visualize subdivision levels.
      - normal: Visualize normal vectors.
    --use-pre-computed-mesh: Load a file with pre-computed DMM generated by a tool included in NVIDIA's DMM SDK.
    --max-compressed-format ***: Forcefully specify a DMM encoding.
      - none: Do not force (encodings are automatically determined)
      - 64utris: Use an encoding with 64 micro triangles, 64B per triangle.
      - 256utris: Use an encoding with 256 micro triangles, 128B per triangle.
      - 1024utris: Use an encoding with 1024 micro triangles, 128B per triangle.
    --max-subdiv-level *: The maximum DMM subdivision level.
    --subdiv-level-bias *: The bias to DMM subdivision level.
    --displacement-bias *: The amount of pre-movement of base vertices along displacement vectors.
    --displacement-scale *: The amount of displacement of base vertices along displacement vectors.
    --no-index-buffer: Specify not to use index buffers for DMM.

    [1] Displacement Micro-Map SDK: https://github.com/NVIDIAGameWorks/Displacement-MicroMap-SDK
        Displacement Micro-Map Toolkit https://github.com/NVIDIAGameWorks/Displacement-MicroMap-Toolkit

*/

#include "displacement_micro_map_shared.h"

#include "../common/obj_loader.h"
#define STB_IMAGE_IMPLEMENTATION
#include "../../ext/stb_image.h"

#include <tiny_gltf.h>

#include <baryutils/baryutils.h>

#include "../common/gui_common.h"



int32_t main(int32_t argc, const char* argv[]) try {
    const std::filesystem::path resourceDir = getExecutableDirectory() / "displacement_micro_map";

    bool takeScreenShot = false;
    bool useDMM = true;
    bool usePreComputedMesh = false;
    auto visualizationMode = Shared::VisualizationMode_Final;
    shared::DMMEncoding maxCompressedFormat = shared::DMMEncoding_None;
    shared::DMMSubdivLevel maxDmmSubDivLevel = shared::DMMSubdivLevel_5;
    int32_t dmmSubdivLevelBias = 0;
    bool useDmmIndexBuffer = true;

    // Hard coded values for runtime DMM generation path in this sample.
    float displacementBias = /*0.0f*/-5.0f;
    float displacementScale = /*1.0f*/10.0f;

    uint32_t argIdx = 1;
    while (argIdx < argc) {
        std::string_view arg = argv[argIdx];
        if (arg == "--screen-shot") {
            takeScreenShot = true;
        }
        else if (arg == "--no-dmm") {
            useDMM = false;
        }
        else if (arg == "--visualize") {
            if (argIdx + 1 >= argc)
                throw std::runtime_error("Argument for --visualize is not complete.");
            std::string_view visType = argv[argIdx + 1];
            if (visType == "final")
                visualizationMode = Shared::VisualizationMode_Final;
            else if (visType == "barycentric")
                visualizationMode = Shared::VisualizationMode_Barycentric;
            else if (visType == "micro-barycentric")
                visualizationMode = Shared::VisualizationMode_MicroBarycentric;
            else if (visType == "subdiv-level")
                visualizationMode = Shared::VisualizationMode_SubdivLevel;
            else if (visType == "normal")
                visualizationMode = Shared::VisualizationMode_Normal;
            else
                throw std::runtime_error("Argument for --visualize is invalid.");
            argIdx += 1;
        }
        else if (arg == "--use-pre-computed-mesh") {
            usePreComputedMesh = true;
        }
        else if (arg == "--max-compressed-format") {
            if (argIdx + 1 >= argc)
                throw std::runtime_error("Argument for --max-compressed-format is not complete.");
            std::string_view visType = argv[argIdx + 1];
            if (visType == "none")
                maxCompressedFormat = shared::DMMEncoding_None;
            else if (visType == "64utris")
                maxCompressedFormat = shared::DMMEncoding_64B_per_64MicroTris;
            else if (visType == "256utris")
                maxCompressedFormat = shared::DMMEncoding_128B_per_256MicroTris;
            else if (visType == "1024utris")
                maxCompressedFormat = shared::DMMEncoding_128B_per_1024MicroTris;
            else
                throw std::runtime_error("Argument for --max-compressed-format is invalid.");
            argIdx += 1;
        }
        else if (arg == "--max-subdiv-level") {
            if (argIdx + 1 >= argc)
                throw std::runtime_error("Argument for --max-subdiv-level is not complete.");
            int32_t level = std::atoi(argv[argIdx + 1]);
            if (level < 0 || level > shared::DMMSubdivLevel_5)
                throw std::runtime_error("Invalid DMM subdivision level.");
            maxDmmSubDivLevel = static_cast<shared::DMMSubdivLevel>(level);
            argIdx += 1;
        }
        else if (arg == "--subdiv-level-bias") {
            if (argIdx + 1 >= argc)
                throw std::runtime_error("Argument for --subdiv-level-bias is not complete.");
            dmmSubdivLevelBias = std::atoi(argv[argIdx + 1]);
            argIdx += 1;
        }
        else if (arg == "--no-index-buffer") {
            useDmmIndexBuffer = false;
        }
        else if (arg == "--displacement-bias") {
            if (argIdx + 1 >= argc)
                throw std::runtime_error("Argument for --displacement-bias is not complete.");
            displacementBias = std::atof(argv[argIdx + 1]);
            argIdx += 1;
        }
        else if (arg == "--displacement-scale") {
            if (argIdx + 1 >= argc)
                throw std::runtime_error("Argument for --displacement-scale is not complete.");
            displacementScale = std::atof(argv[argIdx + 1]);
            argIdx += 1;
        }
        else
            throw std::runtime_error("Unknown command line argument.");
        ++argIdx;
    }



    // ----------------------------------------------------------------
    // JP: OptiXのコンテキストとパイプラインの設定。
    // EN: Settings for OptiX context and pipeline.

    CUcontext cuContext;
    CUstream stream;
    CUDADRV_CHECK(cuInit(0));
    CUDADRV_CHECK(cuCtxCreate(&cuContext, 0, 0));
    CUDADRV_CHECK(cuCtxSetCurrent(cuContext));
    CUDADRV_CHECK(cuStreamCreate(&stream, 0));

    optixu::Context optixContext = optixu::Context::create(
        cuContext, 4,
        optixu::EnableValidation::DEBUG_SELECT(Yes, No));

    optixu::Pipeline pipeline = optixContext.createPipeline();

    // JP: Displacement Micro-Mapを使う場合、プリミティブ種別のフラグを適切に設定する必要がある。
    // EN: Appropriately setting primitive type flags is required when using displacement micro-map.
    pipeline.setPipelineOptions(
        std::max(Shared::PrimaryRayPayloadSignature::numDwords,
                 Shared::VisibilityRayPayloadSignature::numDwords),
        optixu::calcSumDwords<float2>(),
        "plp", sizeof(Shared::PipelineLaunchParameters),
        OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_LEVEL_INSTANCING,
        OPTIX_EXCEPTION_FLAG_STACK_OVERFLOW | OPTIX_EXCEPTION_FLAG_TRACE_DEPTH,
        OPTIX_PRIMITIVE_TYPE_FLAGS_TRIANGLE |
        OPTIX_PRIMITIVE_TYPE_FLAGS_DISPLACED_MICROMESH_TRIANGLE,
        optixu::UseMotionBlur::No);

    const std::vector<char> optixIr =
        readBinaryFile(resourceDir / "ptxes/optix_kernels.optixir");
    optixu::Module moduleOptiX = pipeline.createModuleFromOptixIR(
        optixIr, OPTIX_COMPILE_DEFAULT_MAX_REGISTER_COUNT,
        OPTIX_COMPILE_OPTIMIZATION_DEFAULT/*DEBUG_SELECT(OPTIX_COMPILE_OPTIMIZATION_LEVEL_0, OPTIX_COMPILE_OPTIMIZATION_DEFAULT)*/,
        OPTIX_COMPILE_DEBUG_LEVEL_NONE/*DEBUG_SELECT(OPTIX_COMPILE_DEBUG_LEVEL_FULL, OPTIX_COMPILE_DEBUG_LEVEL_NONE)*/);

    optixu::Module emptyModule;

    optixu::Program rayGenProgram =
        pipeline.createRayGenProgram(moduleOptiX, RT_RG_NAME_STR("raygen"));
    //optixu::Program exceptionProgram = pipeline.createExceptionProgram(moduleOptiX, "__exception__print");

    optixu::Program missProgram = pipeline.createMissProgram(
        moduleOptiX, RT_MS_NAME_STR("miss"));
    optixu::Program emptyMissProgram = pipeline.createMissProgram(emptyModule, nullptr);

    optixu::HitProgramGroup shadingHitProgramGroup = pipeline.createHitProgramGroupForTriangleIS(
        moduleOptiX, RT_CH_NAME_STR("shading"),
        emptyModule, nullptr);
    optixu::HitProgramGroup visibilityHitProgramGroup = pipeline.createHitProgramGroupForTriangleIS(
        emptyModule, nullptr,
        moduleOptiX, RT_AH_NAME_STR("visibility"));

    pipeline.link(2);

    pipeline.setRayGenerationProgram(rayGenProgram);
    // If an exception program is not set but exception flags are set,
    // the default exception program will by provided by OptiX.
    //pipeline.setExceptionProgram(exceptionProgram);
    pipeline.setNumMissRayTypes(Shared::NumRayTypes);
    pipeline.setMissProgram(Shared::RayType_Primary, missProgram);
    pipeline.setMissProgram(Shared::RayType_Visibility, emptyMissProgram);

    cudau::Buffer shaderBindingTable;
    size_t sbtSize;
    pipeline.generateShaderBindingTableLayout(&sbtSize);
    shaderBindingTable.initialize(cuContext, cudau::BufferType::Device, sbtSize, 1);
    shaderBindingTable.setMappedMemoryPersistent(true);
    pipeline.setShaderBindingTable(shaderBindingTable, shaderBindingTable.getMappedPointer());

    // END: Settings for OptiX context and pipeline.
    // ----------------------------------------------------------------



    // ----------------------------------------------------------------
    // JP: マテリアルのセットアップ。
    // EN: Setup materials.

    constexpr bool useBlockCompressedTexture = true;

    optixu::Material defaultMat = optixContext.createMaterial();
    defaultMat.setHitGroup(Shared::RayType_Primary, shadingHitProgramGroup);
    defaultMat.setHitGroup(Shared::RayType_Visibility, visibilityHitProgramGroup);

    // END: Setup materials.
    // ----------------------------------------------------------------



    // ----------------------------------------------------------------
    // JP: シーンのセットアップ。
    // EN: Setup a scene.

    optixu::Scene scene = optixContext.createScene();

    size_t maxScratchMemSizeForAS = 0;
    OptixAccelBufferSizes asMemReqs;

    cudau::Buffer dmmBuildScratchMem;
    cudau::Buffer asBuildScratchMem;

    constexpr optixu::IndexSize dmmIndexSize = optixu::IndexSize::k2Bytes;

    struct Geometry {
        struct MaterialGroup {
            TypedBufferRef<Shared::Vertex> vertexBuffer;
            TypedBufferRef<Shared::Triangle> triangleBuffer;
            optixu::GeometryInstance optixGeomInst;
            ArrayRef albedoTexArray;
            CUtexObject albedoTexObj;
            ArrayRef normalTexArray;
            CUtexObject normalTexObj;
            ArrayRef heightTexArray;
            CUtexObject heightTexObj;

            // JP: これらはDMM Arrayが関連づくGASがビルドされた時点で不要になる。
            // EN: These are disposable once the GAS to which the DMM array associated is built.
            BufferRef dmmDirectionBuffer;
            BufferRef dmmVertexBiasAndScaleBuffer;
            TypedBufferRef<OptixDisplacementMicromapTriangleFlags> dmmTriangleFlagsBuffer;
            BufferRef dmmIndexBuffer;
        };
        std::vector<MaterialGroup> matGroups;
        optixu::GeometryAccelerationStructure optixGas;
        cudau::Buffer gasMem;
        size_t compactedSize;

        void finalize() {
            gasMem.finalize();
            optixGas.destroy();
            for (auto it = matGroups.rbegin(); it != matGroups.rend(); ++it) {
                it->dmmIndexBuffer = nullptr;
                it->dmmTriangleFlagsBuffer = nullptr;
                it->dmmVertexBiasAndScaleBuffer = nullptr;
                it->dmmDirectionBuffer = nullptr;

                if (it->heightTexObj) {
                    CUDADRV_CHECK(cuTexObjectDestroy(it->heightTexObj));
                    it->heightTexArray = nullptr;
                }
                if (it->normalTexObj) {
                    CUDADRV_CHECK(cuTexObjectDestroy(it->normalTexObj));
                    it->normalTexArray = nullptr;
                }
                if (it->albedoTexObj) {
                    CUDADRV_CHECK(cuTexObjectDestroy(it->albedoTexObj));
                    it->albedoTexArray = nullptr;
                }
                it->triangleBuffer = nullptr;
                it->vertexBuffer = nullptr;
                it->optixGeomInst.destroy();
            }
            matGroups.clear();
        }
    };

    struct DMMArray {
        std::vector<OptixDisplacementMicromapHistogramEntry> histogram;
        optixu::DisplacementMicroMapArray optixDmmArray;
        BufferRef arrayMem;

        // JP: これはDMM Arrayがビルドされた時点で不要になる。
        // EN: This is disposable once the DMM array is built.
        TypedBufferRef<OptixDisplacementMicromapDesc> descs;

        void finalize() {
            descs = nullptr;
            arrayMem = nullptr;
            optixDmmArray.destroy();
        }
    };

    struct DMMGroup {
        // JP: これはDMM Arrayがビルドされた時点で不要になる。
        // EN: This is disposable once the DMM array is built.
        BufferRef rawDmmArray;
        std::vector<DMMArray> arrays;

        void finalize() {
            for (auto it = arrays.rbegin(); it != arrays.rend(); ++it)
                it->finalize();
            arrays.clear();
            rawDmmArray = nullptr;
        }
    };

    struct Instance {
        std::shared_ptr<Geometry> geometry;
        float scale;
        Quaternion orientation;
        float3 translation;
        optixu::Instance optixInst;

        void finalize() {
            optixInst.destroy();
            geometry = nullptr;
        }
    };

    std::vector<std::shared_ptr<Geometry>> geometries;
    std::vector<std::shared_ptr<DMMGroup>> dmmGroups;
    std::vector<Instance> instances;

    // Floor
    {
        Shared::Vertex vertices[] = {
            // floor
            { float3(-100.0f, 0.0f, -100.0f), float3(0, 1, 0), float3(1, 0, 0), float2(0, 0) },
            { float3(-100.0f, 0.0f, 100.0f), float3(0, 1, 0), float3(1, 0, 0), float2(0, 1) },
            { float3(100.0f, 0.0f, 100.0f), float3(0, 1, 0), float3(1, 0, 0), float2(1, 1) },
            { float3(100.0f, 0.0f, -100.0f), float3(0, 1, 0), float3(1, 0, 0), float2(1, 0) },
        };

        Shared::Triangle triangles[] = {
            // floor
            { 0, 1, 2 }, { 0, 2, 3 },
        };

        auto geom = std::make_shared<Geometry>();

        geom->optixGas = scene.createGeometryAccelerationStructure();
        geom->optixGas.setConfiguration(
            optixu::ASTradeoff::PreferFastTrace,
            optixu::AllowUpdate::No,
            optixu::AllowCompaction::Yes);
        geom->optixGas.setNumMaterialSets(1);
        geom->optixGas.setNumRayTypes(0, Shared::NumRayTypes);

        Geometry::MaterialGroup group;
        {
            group.vertexBuffer = createTypedBufferRef<Shared::Vertex>(
                cuContext, cudau::BufferType::Device, vertices, lengthof(vertices));
            group.triangleBuffer = createTypedBufferRef<Shared::Triangle>(
                cuContext, cudau::BufferType::Device, triangles, lengthof(triangles));

            Shared::GeometryInstanceData geomData = {};
            geomData.vertexBuffer = group.vertexBuffer->getROBuffer<enableBufferOobCheck>();
            geomData.triangleBuffer = group.triangleBuffer->getROBuffer<enableBufferOobCheck>();
            geomData.albedoTexture = 0;
            geomData.albedo = float3(0.8f, 0.8f, 0.8f);

            group.optixGeomInst = scene.createGeometryInstance();
            group.optixGeomInst.setVertexBuffer(*group.vertexBuffer.get());
            group.optixGeomInst.setTriangleBuffer(*group.triangleBuffer.get());
            group.optixGeomInst.setNumMaterials(1, optixu::BufferView());
            group.optixGeomInst.setMaterial(0, 0, defaultMat);
            group.optixGeomInst.setGeometryFlags(0, OPTIX_GEOMETRY_FLAG_NONE);
            group.optixGeomInst.setUserData(geomData);

            geom->optixGas.addChild(group.optixGeomInst);
            geom->matGroups.push_back(std::move(group));
        }

        geom->optixGas.prepareForBuild(&asMemReqs);
        geom->gasMem.initialize(cuContext, cudau::BufferType::Device, asMemReqs.outputSizeInBytes, 1);
        maxScratchMemSizeForAS = std::max(maxScratchMemSizeForAS, asMemReqs.tempSizeInBytes);

        geometries.push_back(geom);

        Instance inst;
        inst.geometry = geom;
        inst.optixInst = scene.createInstance();
        inst.optixInst.setChild(geom->optixGas);
        instances.push_back(inst);
    }

    size_t maxScratchMemSizeForDMM = 0;

    // Displaced Meshes
    if (usePreComputedMesh) {
        // JP: こちらのコードパスではあらかじめDMM SDKで計算・ベイクしておいたメッシュとDMMを読む。
        // EN: This code path reads a pre-computed mesh and DMM genenarated by the DMM SDK.

        // JP: このメッシュは586 trisで構成されているが元のメッシュは144,046 tris持っていた。
        //     DMMを使うことでオリジナルのディテールを復活させる。
        // EN: This mesh has 586 triangles while the original mesh had 144,046 tris.
        //     Use DMMs to bring back the original detail.
        std::filesystem::path filePath = R"(../../data/dmm_sdk_test/bunny_baked.gltf)";
        std::filesystem::path fileDir = filePath.parent_path();

        tinygltf::Model model;
        tinygltf::TinyGLTF loader;
        std::string error;
        std::string warning;
        loader.SetImageLoader(
            [](tinygltf::Image* image, const int image_idx, std::string* err,
               std::string* warn, int /*req_width*/, int /*req_height*/,
               const unsigned char* bytes, int size, void* /*user_data*/) {
                   int32_t width, height;
                   int32_t comp;
                   uint8_t* data = stbi_load_from_memory(bytes, size, &width, &height, &comp, 4);

                   image->width = width;
                   image->height = height;
                   image->component = comp;
                   image->bits = 8;
                   image->pixel_type = TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE;
                   image->image.resize(width * height * 4);
                   std::copy(data, data + width * height * 4, image->image.begin());

                   stbi_image_free(data);

                   return true;
            }, nullptr);
        bool ret = loader.LoadASCIIFromFile(&model, &error, &warning, filePath.string());
        Assert(ret, "failed to load the DMM-pre-computed mesh.");

        // JP: DMM SDKの構造体とOptiXの構造体が同一であることの確認。
        // EN: Ensure the structures from the DMM SDK and OptiX are identical.
        static_assert(
            static_cast<uint32_t>(bary::BlockFormatDispC1::eInvalid) == OPTIX_DISPLACEMENT_MICROMAP_FORMAT_NONE &&
            static_cast<uint32_t>(bary::BlockFormatDispC1::eR11_unorm_lvl3_pack512) == OPTIX_DISPLACEMENT_MICROMAP_FORMAT_64_MICRO_TRIS_64_BYTES &&
            static_cast<uint32_t>(bary::BlockFormatDispC1::eR11_unorm_lvl4_pack1024) == OPTIX_DISPLACEMENT_MICROMAP_FORMAT_256_MICRO_TRIS_128_BYTES &&
            static_cast<uint32_t>(bary::BlockFormatDispC1::eR11_unorm_lvl5_pack1024) == OPTIX_DISPLACEMENT_MICROMAP_FORMAT_1024_MICRO_TRIS_128_BYTES,
            "Assumed that bary::BlockFormatDispC1 and OptixDisplacementMicromapFormat have the same values.");
        static_assert(
            sizeof(bary::HistogramEntry) == sizeof(OptixDisplacementMicromapHistogramEntry) &&
            offsetof(bary::HistogramEntry, count) == offsetof(OptixDisplacementMicromapHistogramEntry, count) &&
            offsetof(bary::HistogramEntry, subdivLevel) == offsetof(OptixDisplacementMicromapHistogramEntry, subdivisionLevel) &&
            offsetof(bary::HistogramEntry, blockFormat) == offsetof(OptixDisplacementMicromapHistogramEntry, format),
            "Assumed that bary::HistogramEntry and OptixDisplacementMicromapHistogramEntry have the same layout.");
        static_assert(
            sizeof(bary::Triangle) == sizeof(OptixDisplacementMicromapDesc) &&
            offsetof(bary::Triangle, valuesOffset) == offsetof(OptixDisplacementMicromapDesc, byteOffset) &&
            offsetof(bary::Triangle, subdivLevel) == offsetof(OptixDisplacementMicromapDesc, subdivisionLevel) &&
            offsetof(bary::Triangle, blockFormat) == offsetof(OptixDisplacementMicromapDesc, format),
            "Assumed that bary::Triangle and OptixDisplacementMicromapDesc have the same layout.");

        if (useDMM && model.extensions.count("NV_micromaps")) {
            const auto &microMapExt = model.extensions.at("NV_micromaps").Get<tinygltf::Value::Object>();
            const tinygltf::Value &microMaps = microMapExt.at("micromaps");

            // JP: GLTFファイルに記録されたbaryファイルを読み出し、それぞれからDMM Arrayのセットアップを行う。
            // EN: Read bary files record in the GLTF file, then set up DMM arrays based on each bafy file.
            const uint32_t numBaryFiles = microMaps.Size();
            for (int mmIdx = 0; mmIdx < numBaryFiles; ++mmIdx) {
                const auto &microMap = microMaps.Get(mmIdx).Get<tinygltf::Value::Object>();
                const std::filesystem::path microMapPath = fileDir / microMap.at("uri").Get<std::string>();
                baryutils::BaryFile baryFile;
                baryFile.open(microMapPath.string());
                const bary::BasicView &basicView = baryFile.getBasic();

                auto dmmGroup = std::make_shared<DMMGroup>();
                dmmGroup->rawDmmArray = createBufferRef(
                    cuContext, cudau::BufferType::Device, basicView.values, basicView.valuesInfo->valueCount, 1);

                dmmGroup->arrays.resize(basicView.groupsCount);
                for (int mmGroupIdx = 0; mmGroupIdx < basicView.groupsCount; ++mmGroupIdx) {
                    const bary::Group &srcGroup = basicView.groups[mmGroupIdx];
                    DMMArray &dmmArray = dmmGroup->arrays[mmGroupIdx];

                    dmmArray.optixDmmArray = scene.createDisplacementMicroMapArray();
                    dmmArray.optixDmmArray.setConfiguration(OPTIX_DISPLACEMENT_MICROMAP_FLAG_PREFER_FAST_TRACE);

                    const bary::GroupHistogramRange &histRange = basicView.groupHistogramRanges[mmGroupIdx];
                    const auto hist = reinterpret_cast<const OptixDisplacementMicromapHistogramEntry*>(
                        basicView.histogramEntries + histRange.entryFirst);
                    OptixMicromapBufferSizes sizes;
                    dmmArray.optixDmmArray.computeMemoryUsage(hist, histRange.entryCount, &sizes);
                    dmmArray.histogram.resize(histRange.entryCount);
                    std::copy_n(hist, histRange.entryCount, dmmArray.histogram.data());

                    const auto descs = reinterpret_cast<const OptixDisplacementMicromapDesc*>(
                        basicView.triangles + srcGroup.triangleFirst);
                    dmmArray.descs = createTypedBufferRef<OptixDisplacementMicromapDesc>(
                        cuContext, cudau::BufferType::Device, descs, srcGroup.triangleCount);

                    dmmArray.arrayMem = createBufferRef(
                        cuContext, cudau::BufferType::Device, sizes.outputSizeInBytes, 1);
                    maxScratchMemSizeForDMM = std::max(sizes.tempSizeInBytes, maxScratchMemSizeForDMM);

                    dmmArray.optixDmmArray.setBuffers(
                        *dmmGroup->rawDmmArray.get(), *dmmArray.descs.get(), *dmmArray.arrayMem.get());
                }

                baryFile.close();

                dmmGroups.push_back(dmmGroup);
            }
        }

        const uint32_t baseGeomIdx = geometries.size();
        for (int meshIdx = 0; meshIdx < model.meshes.size(); ++meshIdx) {
            const tinygltf::Mesh &srcMesh = model.meshes[meshIdx];

            auto geom = std::make_shared<Geometry>();

            // JP: DMMを適用するジオメトリやそれを含むGASは通常の三角形用のもので良い。
            // EN: Geometry and GAS to which DMM applied are ones for ordinary triangle mesh.
            geom->optixGas = scene.createGeometryAccelerationStructure();
            geom->optixGas.setConfiguration(
                optixu::ASTradeoff::PreferFastTrace,
                optixu::AllowUpdate::No,
                optixu::AllowCompaction::Yes);
            geom->optixGas.setNumMaterialSets(1);
            geom->optixGas.setNumRayTypes(0, Shared::NumRayTypes);

            for (int primGroupIdx = 0; primGroupIdx < srcMesh.primitives.size(); ++primGroupIdx) {
                const tinygltf::Primitive &srcPrimGroup = srcMesh.primitives[primGroupIdx];
                Geometry::MaterialGroup group;

                // JP: 通常の頂点・三角形情報を読み出す。
                // EN: Read ordinary vertex/triangle information.
                TypedBufferRef<Shared::Vertex> vertexBuffer;
                uint32_t numVertices;
                {
                    const uint8_t* posBuffer = nullptr;
                    const uint8_t* normBuffer = nullptr;
                    const uint8_t* tcBuffer = nullptr;
                    const uint8_t* tangBuffer = nullptr;
                    uint32_t posStride = 0;
                    uint32_t normStride = 0;
                    uint32_t tcStride = 0;
                    uint32_t tangStride = 0;
                    bool hasTexCoords = false;
                    {
                        const tinygltf::Accessor &posAccessor =
                            model.accessors[srcPrimGroup.attributes.at("POSITION")];
                        const tinygltf::BufferView &posView = model.bufferViews[posAccessor.bufferView];
                        posBuffer = model.buffers[posView.buffer].data.data()
                            + posView.byteOffset + posAccessor.byteOffset;
                        posStride = posAccessor.ByteStride(posView);

                        const tinygltf::Accessor &normAccessor =
                            model.accessors[srcPrimGroup.attributes.at("NORMAL")];
                        const tinygltf::BufferView &normView = model.bufferViews[normAccessor.bufferView];
                        normBuffer = model.buffers[normView.buffer].data.data()
                            + normView.byteOffset + normAccessor.byteOffset;
                        normStride = normAccessor.ByteStride(normView);

                        const tinygltf::Accessor &tangAccessor =
                            model.accessors[srcPrimGroup.attributes.at("TANGENT")];
                        const tinygltf::BufferView &tangView = model.bufferViews[tangAccessor.bufferView];
                        tangBuffer = model.buffers[tangView.buffer].data.data()
                            + tangView.byteOffset + tangAccessor.byteOffset;
                        tangStride = tangAccessor.ByteStride(tangView);

                        if (srcPrimGroup.attributes.count("TEXCOORD_0")) {
                            hasTexCoords = true;
                            const tinygltf::Accessor &tcAccessor =
                                model.accessors[srcPrimGroup.attributes.at("TEXCOORD_0")];
                            tinygltf::BufferView tcView = model.bufferViews[tcAccessor.bufferView];
                            tcBuffer = model.buffers[tcView.buffer].data.data()
                                + tcView.byteOffset + tcAccessor.byteOffset;
                            tcStride = tcAccessor.ByteStride(tcView);
                        }

                        numVertices = posAccessor.count;
                    }

                    std::vector<Shared::Vertex> vertices(numVertices);
                    for (int vIdx = 0; vIdx < numVertices; ++vIdx) {
                        Shared::Vertex vertex;
                        vertex.position =
                            *reinterpret_cast<const float3*>(&posBuffer[posStride * vIdx]);
                        vertex.normal =
                            *reinterpret_cast<const float3*>(&normBuffer[normStride * vIdx]);
                        vertex.tc0Direction =
                            *reinterpret_cast<const float3*>(&tangBuffer[tangStride * vIdx]);
                        if (hasTexCoords) {
                            vertex.texCoord =
                                *reinterpret_cast<const float2*>(&tcBuffer[tcStride * vIdx]);
                        }
                        else {
                            vertex.texCoord = float2(0.0f, 0.0f);
                        }

                        vertices[vIdx] = vertex;
                    }

                    vertexBuffer = createTypedBufferRef<Shared::Vertex>(
                        cuContext, cudau::BufferType::Device, vertices);
                }

                TypedBufferRef<Shared::Triangle> triangleBuffer;
                uint32_t numTriangles;
                {
                    const tinygltf::Accessor &indexAccessor = model.accessors[srcPrimGroup.indices];
                    const tinygltf::BufferView &indexView = model.bufferViews[indexAccessor.bufferView];
                    const uint8_t* indexBuffer = model.buffers[indexView.buffer].data.data()
                        + indexView.byteOffset + indexAccessor.byteOffset;
                    uint32_t indexStride = indexAccessor.ByteStride(indexView);
                    numTriangles = indexAccessor.count / 3;
                    std::vector<Shared::Triangle> triangles(numTriangles);
                    for (int triIdx = 0; triIdx < numTriangles; ++triIdx) {
                        triangles[triIdx] = Shared::Triangle{
                            *reinterpret_cast<const uint32_t*>(&indexBuffer[indexStride * (3 * triIdx + 0)]),
                            *reinterpret_cast<const uint32_t*>(&indexBuffer[indexStride * (3 * triIdx + 1)]),
                            *reinterpret_cast<const uint32_t*>(&indexBuffer[indexStride * (3 * triIdx + 2)])
                        };
                    }

                    triangleBuffer = createTypedBufferRef<Shared::Triangle>(
                        cuContext, cudau::BufferType::Device, triangles);
                }

                group.vertexBuffer = vertexBuffer;
                group.triangleBuffer = triangleBuffer;
                group.albedoTexObj = 0;
                group.normalTexObj = 0;
                group.heightTexObj = 0;

                Shared::GeometryInstanceData geomData = {};
                geomData.vertexBuffer = group.vertexBuffer->getROBuffer<enableBufferOobCheck>();
                geomData.triangleBuffer = group.triangleBuffer->getROBuffer<enableBufferOobCheck>();
                geomData.albedo = float3(0.9f, 0.2f, 0.01f);

                group.optixGeomInst = scene.createGeometryInstance();
                group.optixGeomInst.setVertexBuffer(*group.vertexBuffer.get());
                group.optixGeomInst.setTriangleBuffer(*group.triangleBuffer.get());
                group.optixGeomInst.setNumMaterials(1, optixu::BufferView());
                group.optixGeomInst.setMaterial(0, 0, defaultMat);
                group.optixGeomInst.setGeometryFlags(0, OPTIX_GEOMETRY_FLAG_NONE);

                // JP: DMM関連の頂点・三角形情報を読み出す。
                // EN: Read DMM-related vertex/triangle information.
                if (useDMM && srcPrimGroup.extensions.count("NV_displacement_micromap")) {
                    const auto &mmAttrs =
                        srcPrimGroup.extensions.at("NV_displacement_micromap").Get<tinygltf::Value::Object>();

                    const int32_t microMapIdx = mmAttrs.at("micromap").GetNumberAsInt();
                    int32_t microMapGroupIdx = 0;
                    if (mmAttrs.count("groupIndex"))
                        microMapGroupIdx = mmAttrs.at("groupIndex").GetNumberAsInt();

                    const DMMArray &dmmArray = dmmGroups[microMapIdx]->arrays[microMapGroupIdx];
                    geomData.dmmDescBuffer = dmmArray.descs->getROBuffer<enableBufferOobCheck>();
                    //geomData.dmmIndexBuffer = ;
                    //geomData.dmmIndexSize = ;

                    struct DisplacementDirAndBounds {
                        float3 direction;
                        float2 scaleAndBias;
                    };

                    BufferRef dispDirAndBoundsBuffer;
                    {
                        const tinygltf::Accessor &dispDirAccessor =
                            model.accessors[mmAttrs.at("directions").GetNumberAsInt()];
                        const tinygltf::Accessor &dispBoundsAccessor =
                            model.accessors[mmAttrs.at("directionBounds").GetNumberAsInt()];
                        const tinygltf::BufferView &dispDirView = model.bufferViews[dispDirAccessor.bufferView];
                        const tinygltf::BufferView &dispBoundsView = model.bufferViews[dispBoundsAccessor.bufferView];
                        const uint8_t* dispDirBuffer = model.buffers[dispDirView.buffer].data.data()
                            + dispDirView.byteOffset + dispDirAccessor.byteOffset;
                        const uint8_t* dispBoundsBuffer = model.buffers[dispBoundsView.buffer].data.data()
                            + dispBoundsView.byteOffset + dispBoundsAccessor.byteOffset;
                        const uint32_t dispDirStride = dispDirAccessor.ByteStride(dispDirView);
                        const uint32_t dispBoundsStride = dispBoundsAccessor.ByteStride(dispBoundsView);

                        Assert(
                            dispDirAccessor.componentType == TINYGLTF_COMPONENT_TYPE_FLOAT &&
                            dispBoundsAccessor.componentType == TINYGLTF_COMPONENT_TYPE_FLOAT,
                            "Unexpected type.");
                        Assert(
                            dispDirAccessor.count == numVertices &&
                            dispBoundsAccessor.count == numVertices,
                            "Unexpected displacement vertex count.");

                        std::vector<DisplacementDirAndBounds> dispDirAndBounds(numVertices);
                        for (int vIdx = 0; vIdx < numVertices; ++vIdx) {
                            DisplacementDirAndBounds entry;
                            entry.direction = *reinterpret_cast<const float3*>(
                                &dispDirBuffer[dispDirStride * vIdx]);
                            entry.scaleAndBias = *reinterpret_cast<const float2*>(
                                &dispBoundsBuffer[dispBoundsStride * vIdx]);
                            dispDirAndBounds[vIdx] = entry;
                        }

                        dispDirAndBoundsBuffer = createBufferRef(
                            cuContext, cudau::BufferType::Device,
                            dispDirAndBounds.data(), dispDirAndBounds.size(), sizeof(DisplacementDirAndBounds));
                    }
                    group.dmmDirectionBuffer = dispDirAndBoundsBuffer;
                    group.dmmVertexBiasAndScaleBuffer = dispDirAndBoundsBuffer;

                    TypedBufferRef<OptixDisplacementMicromapTriangleFlags> dispFlagsBuffer;
                    if (mmAttrs.count("primitiveFlags")) {
                        const tinygltf::Accessor &dispFlagsAccessor =
                            model.accessors[mmAttrs.at("primitiveFlags").GetNumberAsInt()];
                        const tinygltf::BufferView &dispFlagsView = model.bufferViews[dispFlagsAccessor.bufferView];
                        const uint8_t* dispFlagsBufferOnHost = model.buffers[dispFlagsView.buffer].data.data()
                            + dispFlagsView.byteOffset + dispFlagsAccessor.byteOffset;
                        const uint32_t dispFlagsStride = dispFlagsAccessor.ByteStride(dispFlagsView);
                        Assert(
                            dispFlagsAccessor.componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE,
                            "Unexpected type.");
                        Assert(
                            dispFlagsAccessor.count == numTriangles,
                            "Unexpected displacement triangle count.");

                        std::vector<OptixDisplacementMicromapTriangleFlags> dispFlags(numTriangles);
                        for (int triIdx = 0; triIdx < numTriangles; ++triIdx) {
                            uint32_t value = *reinterpret_cast<const uint32_t*>(
                                &dispFlagsBufferOnHost[dispFlagsStride * triIdx]) & 0xFF;
                            dispFlags[triIdx] = static_cast<OptixDisplacementMicromapTriangleFlags>(value);
                        }

                        dispFlagsBuffer = createTypedBufferRef<OptixDisplacementMicromapTriangleFlags>(
                            cuContext, cudau::BufferType::Device, dispFlags);
                    }
                    else {
                        dispFlagsBuffer = createTypedBufferRef<OptixDisplacementMicromapTriangleFlags>(
                            cuContext, cudau::BufferType::Device, numTriangles,
                            OPTIX_DISPLACEMENT_MICROMAP_TRIANGLE_FLAG_NONE);
                    }
                    group.dmmTriangleFlagsBuffer = dispFlagsBuffer;

                    // JP: メッシュがDMMインデックスバッファーを使わず、かつDMM Array中の全DMMを参照している場合、
                    //     使用数はDMM Array中のヒストグラムと同じになるはず。
                    // EN: When a mesh doesn't use a DMM index buffer and does refer all the DMM in the DMM array,
                    //     the usage counts should be the same as the histogram for the DMM array.
                    std::vector<OptixDisplacementMicromapUsageCount> dmmUsageCounts(dmmArray.histogram.size());
                    for (int i = 0; i < dmmArray.histogram.size(); ++i) {
                        const OptixDisplacementMicromapHistogramEntry &srcEntry = dmmArray.histogram[i];
                        OptixDisplacementMicromapUsageCount entry = {};
                        entry.count = srcEntry.count;
                        entry.subdivisionLevel = srcEntry.subdivisionLevel;
                        entry.format = srcEntry.format;
                        dmmUsageCounts[i] = entry;
                    }

                    // JP: DMM ArrayをGeometryInstanceにセットする。
                    // EN: Set the DMM array to the geometry instance.
                    group.optixGeomInst.setDisplacementMicroMapArray(
                        optixu::BufferView(
                            dispDirAndBoundsBuffer->getCUdeviceptr()
                            + offsetof(DisplacementDirAndBounds, direction),
                            dispDirAndBoundsBuffer->numElements(),
                            sizeof(DisplacementDirAndBounds)),
                        optixu::BufferView(
                            dispDirAndBoundsBuffer->getCUdeviceptr()
                            + offsetof(DisplacementDirAndBounds, scaleAndBias),
                            dispDirAndBoundsBuffer->numElements(),
                            sizeof(DisplacementDirAndBounds)),
                        *group.dmmTriangleFlagsBuffer.get(),
                        dmmArray.optixDmmArray, dmmUsageCounts.data(), dmmUsageCounts.size(),
                        optixu::BufferView(),
                        dmmIndexSize, 0,
                        OPTIX_DISPLACEMENT_MICROMAP_DIRECTION_FORMAT_FLOAT3,
                        OPTIX_DISPLACEMENT_MICROMAP_BIAS_AND_SCALE_FORMAT_FLOAT2);
                }

                const tinygltf::Material &srcMat = model.materials[srcPrimGroup.material];
                {
                    const tinygltf::Image &srcNormalMap = model.images[srcMat.normalTexture.index];
                    group.normalTexArray = createArrayRef();
                    group.normalTexArray->initialize2D(
                        cuContext, cudau::ArrayElementType::UInt8, 4,
                        cudau::ArraySurface::Disable, cudau::ArrayTextureGather::Disable,
                        srcNormalMap.width, srcNormalMap.height, 1);
                    group.normalTexArray->write<uint8_t>(
                        srcNormalMap.image.data(), srcNormalMap.width * srcNormalMap.height * 4);

                    cudau::TextureSampler texSampler;
                    texSampler.setXyFilterMode(cudau::TextureFilterMode::Linear);
                    texSampler.setMipMapFilterMode(cudau::TextureFilterMode::Point);
                    texSampler.setReadMode(cudau::TextureReadMode::NormalizedFloat);
                    texSampler.setWrapMode(0, cudau::TextureWrapMode::Repeat);
                    texSampler.setWrapMode(1, cudau::TextureWrapMode::Repeat);
                    group.normalTexObj = texSampler.createTextureObject(*group.normalTexArray.get());
                    geomData.normalTexture = group.normalTexObj;
                }

                group.optixGeomInst.setUserData(geomData);

                geom->optixGas.addChild(group.optixGeomInst);
                geom->matGroups.push_back(std::move(group));
            }

            geom->optixGas.prepareForBuild(&asMemReqs);
            geom->gasMem.initialize(cuContext, cudau::BufferType::Device, asMemReqs.outputSizeInBytes, 1);
            maxScratchMemSizeForAS = std::max(maxScratchMemSizeForAS, asMemReqs.tempSizeInBytes);

            geometries.push_back(geom);
        }

        // JP: このサンプルでは1レベルのノードを想定している。
        // EN: Assume 1-level nodes for this sample.
        for (int nodeIdx = 0; nodeIdx < model.nodes.size(); ++nodeIdx) {
            const tinygltf::Node &node = model.nodes[nodeIdx];

            const std::shared_ptr<Geometry> &geom = geometries[baseGeomIdx + node.mesh];

            Instance inst;
            inst.geometry = geom;
            inst.scale = 1.0f;
            if (node.scale.size())
                inst.scale = node.scale[0];
            if (node.rotation.size())
                inst.orientation = Quaternion(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]);
            if (node.translation.size())
                inst.translation = float3(node.translation[0], node.translation[1], node.translation[2]);
            inst.optixInst = scene.createInstance();
            inst.optixInst.setChild(geom->optixGas);
            Matrix3x3 matSR = inst.scale * inst.orientation.toMatrix3x3();
            const float xfm[] = {
                matSR.m00, matSR.m01, matSR.m02, inst.translation.x,
                matSR.m10, matSR.m11, matSR.m12, inst.translation.y,
                matSR.m20, matSR.m21, matSR.m22, inst.translation.z,
            };
            inst.optixInst.setTransform(xfm);
            instances.push_back(inst);
        }
    }
    else {
        // JP: こちらのコードパスではDMMの生成もサンプル内で行う。
        //     * 単なるデモ用途でありDMMの品質は高くないことに注意。メッシュのクラックなどが発生する。
        // EN: This code path performs DMM generation in the sample.
        //     * Note that this is just for demonstration and the quality of DMM is not good.
        //       You'll see cracks in the mesh or something.

        std::filesystem::path filePath = R"(../../data/stanford_bunny_309_faces_smooth.obj)";
        std::filesystem::path fileDir = filePath.parent_path();

        std::vector<obj::Vertex> srcVertices;
        std::vector<obj::MaterialGroup> matGroups;
        std::vector<obj::Material> materials;
        obj::load(filePath, &srcVertices, &matGroups, &materials);

        std::vector<Shared::Vertex> vertices(srcVertices.size());
        for (int i = 0; i < vertices.size(); ++i) {
            const obj::Vertex &srcVertex = srcVertices[i];
            Shared::Vertex v = {};
            v.position = srcVertex.position;
            v.normal = srcVertex.normal;
            v.tc0Direction = float3(0, 0, 0);
            v.texCoord = srcVertex.texCoord;
            vertices[i] = v;
        }
        TypedBufferRef<Shared::Vertex> vertexBuffer = createTypedBufferRef<Shared::Vertex>(
            cuContext, cudau::BufferType::Device,
            vertices.data(), vertices.size());

        auto geom = std::make_shared<Geometry>();

        // JP: DMMを適用するジオメトリやそれを含むGASは通常の三角形用のもので良い。
        // EN: Geometry and GAS to which DMM applied are ones for ordinary triangle mesh.
        geom->optixGas = scene.createGeometryAccelerationStructure();
        geom->optixGas.setConfiguration(
            optixu::ASTradeoff::PreferFastTrace,
            optixu::AllowUpdate::No,
            optixu::AllowCompaction::Yes);
        geom->optixGas.setNumMaterialSets(1);
        geom->optixGas.setNumRayTypes(0, Shared::NumRayTypes);

        uint32_t maxNumTrianglesPerGroup = 0;
        for (int groupIdx = 0; groupIdx < matGroups.size(); ++groupIdx) {
            const obj::MaterialGroup &srcGroup = matGroups[groupIdx];
            maxNumTrianglesPerGroup = std::max(
                maxNumTrianglesPerGroup,
                static_cast<uint32_t>(srcGroup.triangles.size()));
        }

        size_t scratchMemSizeForDMM = getScratchMemSizeForDMMGenerator(maxNumTrianglesPerGroup);
        cudau::Buffer scratchMemForDMM;
        scratchMemForDMM.initialize(cuContext, cudau::BufferType::Device, scratchMemSizeForDMM, 1);

        for (int groupIdx = 0; groupIdx < matGroups.size(); ++groupIdx) {
            const obj::MaterialGroup &srcGroup = matGroups[groupIdx];
            const obj::Material &srcMat = materials[srcGroup.materialIndex];
            const uint32_t numTriangles = srcGroup.triangles.size();

            Geometry::MaterialGroup group;
            group.vertexBuffer = vertexBuffer;
            group.triangleBuffer = createTypedBufferRef<Shared::Triangle>(
                cuContext, cudau::BufferType::Device,
                reinterpret_cast<const Shared::Triangle*>(srcGroup.triangles.data()),
                numTriangles);

            Shared::GeometryInstanceData geomData = {};
            geomData.vertexBuffer = group.vertexBuffer->getROBuffer<enableBufferOobCheck>();
            geomData.triangleBuffer = group.triangleBuffer->getROBuffer<enableBufferOobCheck>();
            geomData.albedo = float3(srcMat.diffuse[0], srcMat.diffuse[1], srcMat.diffuse[2]);
            if (!srcMat.diffuseTexPath.empty()) {
                int32_t width, height, n;
                uint8_t* linearImageData = stbi_load(
                    srcMat.diffuseTexPath.string().c_str(),
                    &width, &height, &n, 4);
                group.albedoTexArray = createArrayRef();
                group.albedoTexArray->initialize2D(
                    cuContext, cudau::ArrayElementType::UInt8, 4,
                    cudau::ArraySurface::Disable, cudau::ArrayTextureGather::Disable,
                    width, height, 1);
                group.albedoTexArray->write<uint8_t>(linearImageData, width * height * 4);
                stbi_image_free(linearImageData);

                cudau::TextureSampler texSampler;
                texSampler.setXyFilterMode(cudau::TextureFilterMode::Linear);
                texSampler.setMipMapFilterMode(cudau::TextureFilterMode::Point);
                texSampler.setReadMode(cudau::TextureReadMode::NormalizedFloat_sRGB);
                texSampler.setWrapMode(0, cudau::TextureWrapMode::Repeat);
                texSampler.setWrapMode(1, cudau::TextureWrapMode::Repeat);
                group.albedoTexObj = texSampler.createTextureObject(*group.albedoTexArray.get());
                geomData.albedoTexture = group.albedoTexObj;
            }
            if (!srcMat.bumpTexPath.empty()) {
                int32_t width, height, n;
                uint8_t* linearImageData = stbi_load(
                    srcMat.bumpTexPath.string().c_str(),
                    &width, &height, &n, 1);
                group.heightTexArray = createArrayRef();
                group.heightTexArray->initialize2D(
                    cuContext, cudau::ArrayElementType::UInt8, 1,
                    cudau::ArraySurface::Disable, cudau::ArrayTextureGather::Disable,
                    width, height, 1);
                group.heightTexArray->write<uint8_t>(linearImageData, width * height);
                stbi_image_free(linearImageData);

                cudau::TextureSampler texSampler;
                texSampler.setXyFilterMode(cudau::TextureFilterMode::Linear);
                texSampler.setMipMapFilterMode(cudau::TextureFilterMode::Point);
                texSampler.setReadMode(cudau::TextureReadMode::NormalizedFloat);
                texSampler.setWrapMode(0, cudau::TextureWrapMode::Repeat);
                texSampler.setWrapMode(1, cudau::TextureWrapMode::Repeat);
                group.heightTexObj = texSampler.createTextureObject(*group.heightTexArray.get());
                //geomData.heightTexture = group.heightTexObj;
            }

            // JP: まずは各三角形のDMMフォーマットを決定する。
            // EN: Fisrt, determine the DMM format of each triangle.
            DMMGeneratorContext dmmContext;
            uint32_t histInDMMArray[shared::NumDMMEncodingTypes][shared::NumDMMSubdivLevels];
            uint32_t histInMesh[shared::NumDMMEncodingTypes][shared::NumDMMSubdivLevels];
            uint64_t rawDmmArraySize = 0;
            if (useDMM) {
                initializeDMMGeneratorContext(
                    resourceDir / "ptxes",
                    group.vertexBuffer->getCUdeviceptr() + offsetof(Shared::Vertex, position),
                    group.vertexBuffer->getCUdeviceptr() + offsetof(Shared::Vertex, texCoord),
                    sizeof(Shared::Vertex), vertices.size(),
                    group.triangleBuffer->getCUdeviceptr(), sizeof(Shared::Triangle), numTriangles,
                    group.heightTexObj,
                    make_uint2(group.heightTexArray->getWidth(), group.heightTexArray->getHeight()), 1, 0,
                    maxCompressedFormat,
                    shared::DMMSubdivLevel_0, maxDmmSubDivLevel, dmmSubdivLevelBias,
                    useDmmIndexBuffer, 1 << static_cast<uint32_t>(dmmIndexSize),
                    scratchMemForDMM.getCUdeviceptr(), scratchMemForDMM.sizeInBytes(),
                    &dmmContext);

                countDMMFormats(dmmContext, histInDMMArray, histInMesh, &rawDmmArraySize);
            }

            auto dmmGroup = std::make_shared<DMMGroup>();

            std::vector<OptixDisplacementMicromapUsageCount> dmmUsageCounts;
            hpprintf("(%u tris): DMM %s\n",
                     numTriangles, rawDmmArraySize > 0 ? "Enabled" : "Disabled");
            hpprintf("DMM Array Size: %llu [bytes]\n", rawDmmArraySize);
            if (rawDmmArraySize > 0) {
                uint32_t numDmms = 0;
                std::vector<OptixDisplacementMicromapHistogramEntry> dmmHistogramEntries;
                hpprintf("Histogram in DMM Array, Mesh\n");
                hpprintf("         None    : %5u, %5u\n",
                            histInDMMArray[shared::DMMEncoding_None][0],
                            histInMesh[shared::DMMEncoding_None][0]);
                for (int enc = shared::DMMEncoding_64B_per_64MicroTris; enc <= shared::DMMEncoding_128B_per_1024MicroTris; ++enc) {
                    for (int level = shared::DMMSubdivLevel_0; level <= shared::DMMSubdivLevel_5; ++level) {
                        uint32_t countInDmmArray = histInDMMArray[enc][level];
                        uint32_t countInMesh = histInMesh[enc][level];
                        hpprintf("  Enc %u - Level %u: %5u, %5u\n", enc, level, countInDmmArray, countInMesh);

                        if (countInDmmArray > 0) {
                            OptixDisplacementMicromapHistogramEntry histEntry;
                            histEntry.count = countInDmmArray;
                            histEntry.format = static_cast<OptixDisplacementMicromapFormat>(enc);
                            histEntry.subdivisionLevel = level;
                            dmmHistogramEntries.push_back(histEntry);

                            numDmms += histInDMMArray[enc][level];
                        }

                        if (countInMesh > 0) {
                            OptixDisplacementMicromapUsageCount histEntry;
                            histEntry.count = countInMesh;
                            histEntry.format = static_cast<OptixDisplacementMicromapFormat>(enc);
                            histEntry.subdivisionLevel = level;
                            dmmUsageCounts.push_back(histEntry);
                        }
                    }
                }
                hpprintf("\n");

                dmmGroup->arrays.resize(1);
                DMMArray &dmmArray = dmmGroup->arrays[0];

                dmmArray.optixDmmArray = scene.createDisplacementMicroMapArray();

                OptixMicromapBufferSizes dmmArraySizes;
                dmmArray.optixDmmArray.setConfiguration(OPTIX_DISPLACEMENT_MICROMAP_FLAG_PREFER_FAST_TRACE);
                dmmArray.optixDmmArray.computeMemoryUsage(
                    dmmHistogramEntries.data(), dmmHistogramEntries.size(), &dmmArraySizes);
                dmmArray.arrayMem = createBufferRef(
                    cuContext, cudau::BufferType::Device, dmmArraySizes.outputSizeInBytes, 1);

                maxScratchMemSizeForDMM = std::max(dmmArraySizes.tempSizeInBytes, maxScratchMemSizeForDMM);



                dmmGroup->rawDmmArray = createBufferRef(cuContext, cudau::BufferType::Device, rawDmmArraySize, 1);
                dmmArray.descs = createTypedBufferRef<OptixDisplacementMicromapDesc>(
                    cuContext, cudau::BufferType::Device, numDmms);
                geomData.dmmDescBuffer = dmmArray.descs->getROBuffer<enableBufferOobCheck>();
                if (useDmmIndexBuffer) {
                    group.dmmIndexBuffer = createBufferRef(
                        cuContext, cudau::BufferType::Device,
                        numTriangles, 1 << static_cast<uint32_t>(dmmIndexSize));
                    geomData.dmmIndexBuffer = group.dmmIndexBuffer->getCUdeviceptr();
                    geomData.dmmIndexSize = 1 << static_cast<uint32_t>(dmmIndexSize);
                }
                dmmArray.optixDmmArray.setBuffers(
                    *dmmGroup->rawDmmArray.get(), *dmmArray.descs.get(), *dmmArray.arrayMem.get());

                group.dmmTriangleFlagsBuffer = createTypedBufferRef<OptixDisplacementMicromapTriangleFlags>(
                    cuContext, cudau::BufferType::Device, numTriangles);

                // JP: 各三角形のDMMを生成する。
                // EN: Generate an DMM for each triangle.
                generateDMMArray(
                    dmmContext,
                    *dmmGroup->rawDmmArray.get(), *dmmArray.descs.get(), *group.dmmIndexBuffer.get(),
                    *group.dmmTriangleFlagsBuffer.get());

                /*
                JP: 頂点ごとにディスプレイスメントのスケールと事前移動量を指定できる。
                    DMMに記録されているマイクロ頂点ごとの変位量と併せて、ディスプレイスメント適用後
                    のメッシュを最小限に含むように調節することでより高効率かつ高精度なレイトレースが可能となる。
                    が、このサンプルではシンプルにグローバルな値を指定する。
                EN: Specify displacement scale and the amount of pre-movement per vertex.
                    These amounts should be adjusted along with displacement amounts per micro-vertices in DMM
                    so that these tightly encapsulates the diplaced mesh for faster and more precise ray tracing.
                    However, this sample simply specifies globally uniform values.
                */
                std::vector<float2> vertexBiasAndScaleBuffer(
                    vertices.size(), float2(displacementBias, displacementScale));
                group.dmmVertexBiasAndScaleBuffer = createTypedBufferRef<float2>(
                    cuContext, cudau::BufferType::Device, vertexBiasAndScaleBuffer);
            }

            group.optixGeomInst = scene.createGeometryInstance();
            group.optixGeomInst.setVertexBuffer(*group.vertexBuffer.get());
            group.optixGeomInst.setTriangleBuffer(*group.triangleBuffer.get());
            // JP: DMM ArrayをGeometryInstanceにセットする。
            // EN: Set the DMM array to the geometry instance.
            if (useDMM && dmmGroup->arrays[0].optixDmmArray)
                group.optixGeomInst.setDisplacementMicroMapArray(
                    // JP: 頂点ごとのディスプレイスメント方向として法線ベクトルを再利用する。
                    // EN: Reuse the normal vectors as displacement directions per vertex.
                    optixu::BufferView(
                        group.vertexBuffer->getCUdeviceptr() + offsetof(Shared::Vertex, normal),
                        group.vertexBuffer->numElements(),
                        sizeof(Shared::Vertex)),
                    *group.dmmVertexBiasAndScaleBuffer.get(),
                    *group.dmmTriangleFlagsBuffer.get(),
                    dmmGroup->arrays[0].optixDmmArray, dmmUsageCounts.data(), dmmUsageCounts.size(),
                    useDmmIndexBuffer ? *group.dmmIndexBuffer.get() : optixu::BufferView(),
                    dmmIndexSize, 0,
                    OPTIX_DISPLACEMENT_MICROMAP_DIRECTION_FORMAT_FLOAT3,
                    OPTIX_DISPLACEMENT_MICROMAP_BIAS_AND_SCALE_FORMAT_FLOAT2);
            group.optixGeomInst.setNumMaterials(1, optixu::BufferView());
            group.optixGeomInst.setMaterial(0, 0, defaultMat);
            group.optixGeomInst.setGeometryFlags(0, OPTIX_GEOMETRY_FLAG_NONE);
            group.optixGeomInst.setUserData(geomData);

            geom->optixGas.addChild(group.optixGeomInst);
            geom->matGroups.push_back(std::move(group));
            dmmGroups.push_back(dmmGroup);
        }

        scratchMemForDMM.finalize();

        geom->optixGas.prepareForBuild(&asMemReqs);
        geom->gasMem.initialize(cuContext, cudau::BufferType::Device, asMemReqs.outputSizeInBytes, 1);
        maxScratchMemSizeForAS = std::max(maxScratchMemSizeForAS, asMemReqs.tempSizeInBytes);

        geometries.push_back(geom);

        Instance inst;
        inst.geometry = geom;
        inst.scale = 0.05f;
        inst.optixInst = scene.createInstance();
        inst.optixInst.setChild(geom->optixGas);
        Matrix3x3 matSR = inst.scale * inst.orientation.toMatrix3x3();
        const float xfm[] = {
            matSR.m00, matSR.m01, matSR.m02, inst.translation.x,
            matSR.m10, matSR.m11, matSR.m12, inst.translation.y,
            matSR.m20, matSR.m21, matSR.m22, inst.translation.z,
        };
        inst.optixInst.setTransform(xfm);
        instances.push_back(inst);
    }



    // JP: Instance Acceleration Structureを生成する。
    // EN: Create an instance acceleration structure.
    optixu::InstanceAccelerationStructure ias = scene.createInstanceAccelerationStructure();
    cudau::Buffer iasMem;
    cudau::TypedBuffer<OptixInstance> instanceBuffer;
    ias.setConfiguration(optixu::ASTradeoff::PreferFastTrace);
    for (int i = 0; i < instances.size(); ++i)
        ias.addChild(instances[i].optixInst);
    ias.prepareForBuild(&asMemReqs);
    iasMem.initialize(cuContext, cudau::BufferType::Device, asMemReqs.outputSizeInBytes, 1);
    instanceBuffer.initialize(cuContext, cudau::BufferType::Device, ias.getNumChildren());
    maxScratchMemSizeForAS = std::max(maxScratchMemSizeForAS, asMemReqs.tempSizeInBytes);



    cudau::Timer dmmBuildTimer;
    cudau::Timer blasBuildTimer;
    dmmBuildTimer.initialize(cuContext);
    blasBuildTimer.initialize(cuContext);
    
    // JP: Displacement Micro-Map Arrayをビルドする。
    // EN: Build displacement micro-map arrays.
    if (useDMM && maxScratchMemSizeForDMM) {
        dmmBuildScratchMem.initialize(cuContext, cudau::BufferType::Device, maxScratchMemSizeForDMM, 1);
        dmmBuildTimer.start(stream);
        for (int groupIdx = 0; groupIdx < dmmGroups.size(); ++groupIdx) {
            const std::shared_ptr<DMMGroup> &dmmGroup = dmmGroups[groupIdx];
            for (int arrayIdx = 0; arrayIdx < dmmGroup->arrays.size(); ++arrayIdx) {
                dmmGroup->arrays[arrayIdx].optixDmmArray.rebuild(stream, dmmBuildScratchMem);
            }
        }
        dmmBuildTimer.stop(stream);
    }



    // JP: ASビルド用のスクラッチメモリを確保する。
    // EN: Allocate scratch memory for AS builds.
    asBuildScratchMem.initialize(cuContext, cudau::BufferType::Device, maxScratchMemSizeForAS, 1);



    // JP: Geometry Acceleration Structureをビルドする。
    // EN: Build geometry acceleration structures.
    blasBuildTimer.start(stream);
    for (int i = 0; i < geometries.size(); ++i) {
        const std::shared_ptr<Geometry> &geom = geometries[i];
        geom->optixGas.rebuild(stream, geom->gasMem, asBuildScratchMem);
    }
    blasBuildTimer.stop(stream);

    // JP: 静的なメッシュはコンパクションもしておく。
    //     複数のメッシュのASをひとつのバッファーに詰めて記録する。
    // EN: Perform compaction for static meshes.
    //     Record ASs of multiple meshes into single buffer back to back.
    struct CompactedASInfo {
        std::shared_ptr<Geometry> geom;
        size_t offset;
        size_t size;
    };
    std::vector<CompactedASInfo> gasList;
    for (int i = 0; i < geometries.size(); ++i) {
        const std::shared_ptr<Geometry> &geom = geometries[i];
        gasList.push_back(CompactedASInfo{ geom, 0, 0 });
    }
    size_t compactedASMemOffset = 0;
    for (int i = 0; i < gasList.size(); ++i) {
        CompactedASInfo &info = gasList[i];
        compactedASMemOffset = alignUp(compactedASMemOffset, OPTIX_ACCEL_BUFFER_BYTE_ALIGNMENT);
        info.offset = compactedASMemOffset;
        info.geom->optixGas.prepareForCompact(&info.size);
        compactedASMemOffset += info.size;
    }
    cudau::Buffer compactedASMem;
    compactedASMem.initialize(cuContext, cudau::BufferType::Device, compactedASMemOffset, 1);
    for (int i = 0; i < gasList.size(); ++i) {
        const CompactedASInfo &info = gasList[i];
        info.geom->optixGas.compact(
            stream,
            optixu::BufferView(compactedASMem.getCUdeviceptr() + info.offset, info.size, 1));
    }
    // JP: removeUncompacted()はcompact()がデバイス上で完了するまでホスト側で待つので呼び出しを分けたほうが良い。
    // EN: removeUncompacted() waits on host-side until the compact() completes on the device,
    //     so separating calls is recommended.
    for (int i = 0; i < gasList.size(); ++i) {
        gasList[i].geom->optixGas.removeUncompacted();
        gasList[i].geom->gasMem.finalize();
    }



    // JP: IASビルド時には各インスタンスのTraversable HandleとShader Binding Table中のオフセットが
    //     確定している必要がある。
    // EN: Traversable handle and offset in the shader binding table must be fixed for each instance
    //     when building an IAS.
    cudau::Buffer hitGroupSBT;
    size_t hitGroupSbtSize;
    scene.generateShaderBindingTableLayout(&hitGroupSbtSize);
    hitGroupSBT.initialize(cuContext, cudau::BufferType::Device, hitGroupSbtSize, 1);
    hitGroupSBT.setMappedMemoryPersistent(true);

    OptixTraversableHandle travHandle = ias.rebuild(stream, instanceBuffer, iasMem, asBuildScratchMem);

    CUDADRV_CHECK(cuStreamSynchronize(stream));

    hpprintf("Stats:\n");
    for (int groupIdx = 0; groupIdx < dmmGroups.size(); ++groupIdx) {
        const std::shared_ptr<DMMGroup> &dmmGroup = dmmGroups[groupIdx];
        for (int arrayIdx = 0; arrayIdx < dmmGroup->arrays.size(); ++arrayIdx) {
            const DMMArray &dmmArray = dmmGroup->arrays[arrayIdx];
            hpprintf("DMM %u-%u: %llu [B]\n", groupIdx, arrayIdx, dmmArray.arrayMem->sizeInBytes());
        }
    }
    const float dmmBuildTime = dmmBuildTimer.report();
    hpprintf("DMM build time: %.3f [ms], Scratch: %llu [B]\n", dmmBuildTime, maxScratchMemSizeForDMM);
    for (int i = 0; i < geometries.size(); ++i) {
        hpprintf("BLAS %u: %llu [B]\n", i, gasList[i].size);
    }
    const float blasBuildTime = blasBuildTimer.report();
    hpprintf("BLAS build time: %.3f [ms], Scratch: %llu [B]\n", blasBuildTime, maxScratchMemSizeForAS);
    hpprintf("\n");

    blasBuildTimer.finalize();
    dmmBuildTimer.finalize();

    // END: Setup a scene.
    // ----------------------------------------------------------------



    constexpr int32_t initWindowContentWidth = 1280;
    constexpr int32_t initWindowContentHeight = 720;
    
    const auto computeHaltonSequence = []
    (uint32_t base, uint32_t idx) {
        const float recBase = 1.0f / base;
        float ret = 0.0f;
        float scale = 1.0f;
        while (idx) {
            scale *= recBase;
            ret += (idx % base) * scale;
            idx /= base;
        }
        return ret;
    };
    float2 subPixelOffsets[64];
    for (int i = 0; i < lengthof(subPixelOffsets); ++i)
        subPixelOffsets[i] = float2(computeHaltonSequence(2, i), computeHaltonSequence(3, i));

    float lightDirPhi = -16;
    float lightDirTheta = 60;
    float lightStrengthInLog10 = 0.8f;

    Shared::PipelineLaunchParameters plp;
    plp.travHandle = travHandle;
    plp.imageSize = int2(initWindowContentWidth, initWindowContentHeight);
    plp.camera.fovY = 50 * pi_v<float> / 180;
    plp.camera.aspect = static_cast<float>(initWindowContentWidth) / initWindowContentHeight;
    plp.envRadiance = float3(0.10f, 0.13f, 0.9f);

    pipeline.setScene(scene);
    pipeline.setHitGroupShaderBindingTable(hitGroupSBT, hitGroupSBT.getMappedPointer());

    CUdeviceptr plpOnDevice;
    CUDADRV_CHECK(cuMemAlloc(&plpOnDevice, sizeof(plp)));



    // ----------------------------------------------------------------
    // JP: ウインドウの表示。
    // EN: Display the window.

    InitialConfig initConfig = {};
    initConfig.windowTitle = "OptiX Utility - Displacement Micro Map";
    initConfig.resourceDir = resourceDir;
    initConfig.windowContentRenderWidth = initWindowContentWidth;
    initConfig.windowContentRenderHeight = initWindowContentHeight;
    initConfig.cameraPosition = float3(0, 3.5f, 6.0f);
    initConfig.cameraOrientation = qRotateY(pi_v<float>) * qRotateX(0.1f * pi_v<float>);
    initConfig.cameraMovingSpeed = 0.1f;
    initConfig.cuContext = cuContext;

    GUIFramework framework;
    framework.initialize(initConfig);

    cudau::Array outputArray;
    outputArray.initializeFromGLTexture2D(
        cuContext, framework.getOutputTexture().getHandle(),
        cudau::ArraySurface::Enable, cudau::ArrayTextureGather::Disable);

    cudau::InteropSurfaceObjectHolder<2> outputBufferSurfaceHolder;
    outputBufferSurfaceHolder.initialize({ &outputArray });

    struct GPUTimer {
        cudau::Timer render;

        void initialize(CUcontext context) {
            render.initialize(context);
        }
        void finalize() {
            render.finalize();
        }
    };

    GPUTimer gpuTimers[2];
    gpuTimers[0].initialize(cuContext);
    gpuTimers[1].initialize(cuContext);

    const auto onRenderLoop = [&]
    (const RunArguments &args) {
        const uint64_t frameIndex = args.frameIndex;
        const CUstream curStream = args.curStream;
        GPUTimer &curGPUTimer = gpuTimers[frameIndex % 2];

        // Camera Window
        bool cameraIsActuallyMoving = args.cameraIsActuallyMoving;
        {
            ImGui::SetNextWindowPos(ImVec2(8, 8), ImGuiCond_FirstUseEver);
            ImGui::Begin("Camera & Rendering", nullptr, ImGuiWindowFlags_AlwaysAutoResize);

            ImGui::Text("W/A/S/D/R/F: Move, Q/E: Tilt");
            ImGui::Text("Mouse Middle Drag: Rotate");

            if (ImGui::InputFloat3("Position", reinterpret_cast<float*>(&args.cameraPosition)))
                cameraIsActuallyMoving = true;
            static float rollPitchYaw[3];
            args.tempCameraOrientation.toEulerAngles(&rollPitchYaw[0], &rollPitchYaw[1], &rollPitchYaw[2]);
            rollPitchYaw[0] *= 180 / pi_v<float>;
            rollPitchYaw[1] *= 180 / pi_v<float>;
            rollPitchYaw[2] *= 180 / pi_v<float>;
            if (ImGui::InputFloat3("Roll/Pitch/Yaw", rollPitchYaw)) {
                args.cameraOrientation = qFromEulerAngles(
                    rollPitchYaw[0] * pi_v<float> / 180,
                    rollPitchYaw[1] * pi_v<float> / 180,
                    rollPitchYaw[2] * pi_v<float> / 180);
                cameraIsActuallyMoving = true;
            }
            ImGui::Text("Pos. Speed (T/G): %g", args.cameraPositionalMovingSpeed);

            ImGui::End();
        }

        plp.camera.position = args.cameraPosition;
        plp.camera.orientation = args.tempCameraOrientation.toMatrix3x3();



        // Debug Window
        static bool drawBaseEdges = false;
        static bool enableNormalMap = true;
        bool visModeChanged = false;
        bool lightParamChanged = false;
        {
            ImGui::SetNextWindowPos(ImVec2(944, 8), ImGuiCond_FirstUseEver);
            ImGui::Begin("Debug", nullptr, ImGuiWindowFlags_AlwaysAutoResize);

            const float oldStrength = lightStrengthInLog10;
            const float oldPhi = lightDirPhi;
            const float oldTheta = lightDirTheta;
            ImGui::SliderFloat("Light Strength", &lightStrengthInLog10, -2, 2);
            ImGui::SliderFloat("Light Phi", &lightDirPhi, -180, 180);
            ImGui::SliderFloat("Light Theta", &lightDirTheta, 0, 90);
            lightParamChanged =
                lightStrengthInLog10 != oldStrength
                || lightDirPhi != oldPhi || lightDirTheta != oldTheta;

            ImGui::Separator();

            ImGui::Text("Buffer to Display");
            visModeChanged |= ImGui::RadioButtonE(
                "Final", &visualizationMode, Shared::VisualizationMode_Final);
            visModeChanged |= ImGui::RadioButtonE(
                "Barycentric", &visualizationMode, Shared::VisualizationMode_Barycentric);
            visModeChanged |= ImGui::RadioButtonE(
                "Micro-Barycentric", &visualizationMode, Shared::VisualizationMode_MicroBarycentric);
            visModeChanged |= ImGui::RadioButtonE(
                "Subdivision Level", &visualizationMode, Shared::VisualizationMode_SubdivLevel);
            visModeChanged |= ImGui::RadioButtonE(
                "Normal", &visualizationMode, Shared::VisualizationMode_Normal);

            visModeChanged |= ImGui::Checkbox("Draw Base Edges", &drawBaseEdges);
            visModeChanged |= ImGui::Checkbox("Enable Normal Map", &enableNormalMap);

            ImGui::End();
        }

        // Stats Window
        {
            ImGui::SetNextWindowPos(ImVec2(8, 144), ImGuiCond_FirstUseEver);
            ImGui::Begin("Stats", nullptr, ImGuiWindowFlags_AlwaysAutoResize);

            static MovingAverageTime renderTime;

            renderTime.append(curGPUTimer.render.report());

            //ImGui::SetNextItemWidth(100.0f);
            ImGui::Text("render: %.3f [ms]", renderTime.getAverage());

            ImGui::End();
        }



        bool firstAccumFrame =
            cameraIsActuallyMoving ||
            args.resized ||
            frameIndex == 0 ||
            lightParamChanged ||
            visModeChanged;
        bool isNewSequence = args.resized || frameIndex == 0;
        static uint32_t numAccumFrames = 0;
        if (firstAccumFrame)
            numAccumFrames = 0;

        outputBufferSurfaceHolder.beginCUDAAccess(curStream);

        // Render
        {
            curGPUTimer.render.start(curStream);

            plp.lightDirection = fromPolarYUp(lightDirPhi * pi_v<float> / 180, lightDirTheta * pi_v<float> / 180);
            plp.lightRadiance = float3(std::pow(10.0f, lightStrengthInLog10));
            plp.colorAccumBuffer = outputBufferSurfaceHolder.getNext();
            plp.visualizationMode = visualizationMode;
            plp.subPixelOffset = subPixelOffsets[numAccumFrames % static_cast<uint32_t>(lengthof(subPixelOffsets))];
            plp.sampleIndex = std::min(numAccumFrames, static_cast<uint32_t>(lengthof(subPixelOffsets)) - 1);
            plp.drawBaseEdges = drawBaseEdges;
            plp.enableNormalMap = enableNormalMap;
            CUDADRV_CHECK(cuMemcpyHtoDAsync(plpOnDevice, &plp, sizeof(plp), curStream));
            pipeline.launch(
                curStream, plpOnDevice, args.windowContentRenderWidth, args.windowContentRenderHeight, 1);
            ++numAccumFrames;

            curGPUTimer.render.stop(curStream);
        }

        outputBufferSurfaceHolder.endCUDAAccess(curStream, true);



        ReturnValuesToRenderLoop ret = {};
        ret.enable_sRGB = visualizationMode == Shared::VisualizationMode_Final;
        ret.finish = false;

        if (takeScreenShot && frameIndex + 1 == lengthof(subPixelOffsets)) {
            CUDADRV_CHECK(cuStreamSynchronize(curStream));
            const uint32_t numPixels = args.windowContentRenderWidth * args.windowContentRenderHeight;
            auto rawImage = new float4[numPixels];
            glGetTextureSubImage(
                args.outputTexture->getHandle(), 0,
                0, 0, 0, args.windowContentRenderWidth, args.windowContentRenderHeight, 1,
                GL_RGBA, GL_FLOAT, sizeof(float4) * numPixels, rawImage);
            saveImage("output.png", args.windowContentRenderWidth, args.windowContentRenderHeight, rawImage,
                      false, ret.enable_sRGB);
            delete[] rawImage;
            ret.finish = true;
        }

        return ret;
    };

    const auto onResolutionChange = [&]
    (CUstream curStream, uint64_t frameIndex,
     int32_t windowContentWidth, int32_t windowContentHeight) {
         outputArray.finalize();
         outputArray.initializeFromGLTexture2D(
             cuContext, framework.getOutputTexture().getHandle(),
             cudau::ArraySurface::Enable, cudau::ArrayTextureGather::Disable);

         // EN: update the pipeline parameters.
         plp.imageSize = int2(windowContentWidth, windowContentHeight);
         plp.camera.aspect = static_cast<float>(windowContentWidth) / windowContentHeight;
    };

    framework.run(onRenderLoop, onResolutionChange);

    gpuTimers[1].finalize();
    gpuTimers[0].finalize();

    outputBufferSurfaceHolder.finalize();
    outputArray.finalize();

    framework.finalize();

    // END: Display the window.
    // ----------------------------------------------------------------



    CUDADRV_CHECK(cuMemFree(plpOnDevice));



    hitGroupSBT.finalize();

    compactedASMem.finalize();

    asBuildScratchMem.finalize();
    dmmBuildScratchMem.finalize();

    instanceBuffer.finalize();
    iasMem.finalize();
    ias.destroy();

    for (int i = instances.size() - 1; i >= 0; --i)
        instances[i].finalize();

    for (int i = dmmGroups.size() - 1; i >= 0; --i)
        dmmGroups[i]->finalize();
    for (int i = geometries.size() - 1; i >= 0; --i)
        geometries[i]->finalize();

    scene.destroy();

    defaultMat.destroy();



    shaderBindingTable.finalize();

    visibilityHitProgramGroup.destroy();
    shadingHitProgramGroup.destroy();

    emptyMissProgram.destroy();
    missProgram.destroy();
    rayGenProgram.destroy();

    moduleOptiX.destroy();

    pipeline.destroy();

    optixContext.destroy();

    CUDADRV_CHECK(cuStreamDestroy(stream));
    CUDADRV_CHECK(cuCtxDestroy(cuContext));

    return 0;
}
catch (const std::exception &ex) {
    hpprintf("Error: %s\n", ex.what());
    return -1;
}
